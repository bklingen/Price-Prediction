---
title: "Predicting House Prices"
output:
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Kaggle Competition
[This Kaggle competition](https://www.kaggle.com/c/house-prices-advanced-regression-techniques/overview) is about predicting house prices based on a set of around 80 predictor variables. Please read the brief description of the project and get familiar with the various predictors. We will have to do some initial cleaning to successfully work with these data. Overall, we (in teams) will use the provided training dataset to built a multiple linear regression model for predicting house prices. Once we have settled on a final model, we will use it with the predictors available in the testing dataset to predict house prices. The goal of the competition mentions that our predictions $\hat{y}_i$ for the houses in the testing data are compared to the (withheld) true selling prices $y_i^\text{test}$ via $\sum_i(\log \hat{y}_i - \log y_i^\text{test})^2$. Because selling prices are typically right-skewed, I think as a first step we will log-transform the selling prices of the houses in the training data to obtain a more bell-shaped distribution. However, although we will built a model for the log-prices, we will still have to submit the price of a house (and not the log-price) to Kaggle, together with the ID of the house.

## Loading and inspecting the train and test datasets

```{r}
library(tidyverse)
library(tidyr)
## Load Training Data
path_traindata <- 'https://raw.githubusercontent.com/bklingen/Price-Prediction/main/train.csv'
train <- read_csv(path_traindata)
dim(train)
## Load Testing Data
path_testdata <- 'https://raw.githubusercontent.com/bklingen/Price-Prediction/main/test.csv'
test <- read_csv(path_testdata)
dim(test)
```

This makes sense: We have one less column in test data because of the missing house prices.

But, are the column names the same? Let's find the "difference" between two sets: All the column names that are in the test data but not in the train data: 
```{r}
setdiff(colnames(test), colnames(train))
```
OK, good, and now the other way around:
```{r}
setdiff(colnames(train), colnames(test))
```
OK, great. So no surprises there. All predictors that exist in the train data set also appear in the test dataset.

Let's see how many quantitative and how many categorical predictors we have in the training dataset, at least at face value:
```{r}
train_quantPredictors = train %>% select(where(is.numeric)) %>% select(-SalePrice) 
train_catPredictors = train %>% select(where(is.character))
dim(train_quantPredictors)
dim(train_catPredictors)
```

Let's quickly do the same split for the test data:
```{r}
test_quantPredictors = test %>% select(where(is.numeric))
test_catPredictors = test %>% select(where(is.character))
```
Let's transform the categorical predictors into factors, which should make it easier to combine categories, create a category like "other", etc. 
```{r}
train_catPredictors = train_catPredictors %>% transmute_all(as.factor)
test_catPredictors = test_catPredictors %>% transmute_all(as.factor)
```

First, let's see the category names and frequency for each variable:
```{r}
for(i in 1:ncol(train_catPredictors)) {
  print(colnames(train_catPredictors)[i])
  print("----")
  print(as.data.frame(fct_count(unlist(train_catPredictors[,i]))))
  print("--------------")
}
```


## Handle Categorical Features

### MSZoning (Mei)
There are no null/missing values in the training set, but there are a few in the test set
```{r}
sum(is.na(train$MSZoning))
sum(is.na(test$MSZoning))
```
Although there are 8 potential categories for this variable, there only exist 5 unique ones in the training and test set. 
```{r}
fct_count(train$MSZoning)
fct_count(test$MSZoning)
```
```{r warning=FALSE}
mszoning.collapse <- function(x) fct_collapse(x,
                  "FV" = c("FV"),
                  "RL" = c("RL", "RP"),
                  "RO" = c("RM", "RH"),
                  other_level = "other")

train <- train %>% mutate(MSZoning = as.factor(MSZoning), MSZoning = mszoning.collapse(MSZoning))
test <- test %>% mutate(MSZoning = as.factor(MSZoning), MSZoning = mszoning.collapse(MSZoning))
```
```{r}
fct_count(train$MSZoning)
```


### MSSubClass (Mei)
There are no null/missing values
```{r}
sum(is.na(train$MSSubClass))
sum(is.na(test$MSSubClass))
```
Assuming the 1/2 story refers to a basement level as "(un)finished" terminology typically refers to, the categories will be split as follows (counts in parenthesis):
  - 1-STORY 1946 & NEWER single-family (536)
  - 1-STORY single-family other
    - 30	1-STORY 1945 & OLDER (69)
    - 40	1-STORY W/FINISHED ATTIC ALL AGES (4)
    - 45	1-1/2 STORY - UNFINISHED ALL AGES (12)
    - 50	1-1/2 STORY FINISHED ALL AGES (144)
  - multi-level single-family non PUD
    - 60	2-STORY 1946 & NEWER (299)
    - 70	2-STORY 1945 & OLDER (60)
    - 75	2-1/2 STORY ALL AGES (16)
    - 80	SPLIT OR MULTI-LEVEL (58)
    - 85	SPLIT FOYER (20)
  - other
    - 90	DUPLEX - ALL STYLES AND AGES (52)
    - 120	1-STORY PUD (Planned Unit Development) - 1946 & NEWER (87)
    - 150	1-1/2 STORY PUD - ALL AGES 
    - 160	2-STORY PUD - 1946 & NEWER (63)
    - 180	PUD - MULTILEVEL - INCL SPLIT LEV/FOYER (10)
    - 190	2 FAMILY CONVERSION - ALL STYLES AND AGES (30)
 
```{r}
mssubclass.collapse <- function(x) fct_collapse(x,
                  "1-story single-family 1946 & newer" = c("20"),
                  "1-story single-family other" = c("30", "40", "45", "50"),
                  "multi-level single-family non PUD" = c("60", "70", "75", "80", "85"),
                  other_level = "other")

train <- train %>% mutate(MSSubClass = as.factor(MSSubClass), MSSubClass = mssubclass.collapse(MSSubClass))
test <- test %>% mutate(MSSubClass = as.factor(MSSubClass), MSSubClass = mssubclass.collapse(MSSubClass))
```
```{r}
fct_count(train$MSSubClass)
```


### Condition1/Condition2 (Mei)
There are no null/missing values
```{r}
sum(is.na(train$Condition1))
sum(is.na(test$Condition1))
sum(is.na(train$Condition2))
sum(is.na(test$Condition2))
```
Collapse similar locations together:
  - All the railroad related locations
  - All the park related locations
  - All the street related locations
This results in only 4 categories:
  - Normal
  - Near railroad
  - Near park
  - Near arterial or feeder street
       
```{r warning=FALSE}
condition.collapse <- function(x) fct_collapse(x,
                  RR = c("RRNn", "RRAn", "RRNe", "RRAe"),
                  Pos = c("PosN", "PosA"),
                  St = c("Artery", "Feedr"))

train <- train %>% mutate_at(vars(Condition1, Condition2), condition.collapse)
test <- test %>% mutate_at(vars(Condition1, Condition2), condition.collapse)
```
```{r}
fct_count(train$Condition1)
```

# Richard's Features

### RoofStyle

**combine flat, shed as other; gambrel, mansard, gable as gable; leave others as is**

```{r}
roof_price <- train %>% group_by(RoofStyle) %>% summarize(count=n(),
  mean(SalePrice), sd(SalePrice))

roof_price
```

```{r}
train$RoofStyle <- fct_collapse(train$RoofStyle, Other = c("Flat", "Shed"))
train$RoofStyle <- fct_collapse(train$RoofStyle, Gable = c("Gable", "Gambrel", "Mansard"))
```
Let's do the same on the testing dataset:
```{r}
test$RoofStyle <- fct_collapse(test$RoofStyle, Other = c("Flat", "Shed"))
test$RoofStyle <- fct_collapse(test$RoofStyle, Gable = c("Gable", "Gambrel", "Mansard"))
```


### BldgType
Combine 2FmCon, Duplex as multifamily; leave others as is

```{r}
bldg_price <- train %>% group_by(BldgType) %>% summarize(count=n(),
  mean(SalePrice), sd(SalePrice))

bldg_price
```

```{r}
train$BldgType <- fct_collapse(train$BldgType, MultiFam = c("2fmCon", "Duplex"))
```
Let's do the same on the testing dataset:
```{r}
test$BldgType <- fct_collapse(test$BldgType, MultiFam = c("2fmCon", "Duplex"))
```

### HouseStyle
Combine 1.5Fin, 1Story, split foyer, split level as less than 2 story; 2.5fin, 2Story as two story or greater; leave 1.5Unf and 2.5Unf as is since they drag down property values

```{r}
style_price <- train %>% group_by(HouseStyle) %>% summarize(count=n(),
  mean(SalePrice), sd(SalePrice))

style_price 
```

```{r}
train$HouseStyle <- fct_collapse(train$HouseStyle, Less2story = c("1Story", "1.5Fin", "SFoyer", "SLvl"))
train$HouseStyle <- fct_collapse(train$HouseStyle, EqMore2story = c("2Story", "2.5Fin"))
```

And on the test data:
```{r}
test$HouseStyle <- fct_collapse(test$HouseStyle, Less2story = c("1Story", "1.5Fin", "SFoyer", "SLvl"))
test$HouseStyle <- fct_collapse(test$HouseStyle, EqMore2story = c("2Story", "2.5Fin"))
```


### Kyle:
```{r}
cleanpool <- as.character(train_catPredictors$PoolQC)
cleanpool[is.na(cleanpool)] <- "none"
cleanpool <- as.factor(cleanpool)
```

```{r}
cleanfence <- as.character(train_catPredictors$Fence)
cleanfence[is.na(cleanfence)] <- "none"
cleanfence <- as.factor(cleanfence)
```

```{r}
cleanfunc <- as.character(train_catPredictors$Functional)
cleanfunc[cleanfunc == 'Min1' | cleanfunc == 'Min2'] <- "Minor"
cleanfunc[cleanfunc == 'Maj1' | cleanfunc == 'Maj2'] <- "Major"
cleanfunc[cleanfunc == 'Sev' | cleanfunc == 'Sal'] <- "Severe"
cleanfunc <- as.factor(cleanfunc)
```

```{r}
train$PoolQC <- cleanpool
train$Fence <- cleanfence
train$Functional <- cleanfunc
```

We need to do the same for the test dataset, so I just copied the code block and replaced "train" by "test":
```{r}
cleanpool <- as.character(test_catPredictors$PoolQC)
cleanpool[is.na(cleanpool)] <- "none"
cleanpool <- as.factor(cleanpool)
```

```{r}
cleanfence <- as.character(test_catPredictors$Fence)
cleanfence[is.na(cleanfence)] <- "none"
cleanfence <- as.factor(cleanfence)
```

```{r}
cleanfunc <- as.character(test_catPredictors$Functional)
cleanfunc[cleanfunc == 'Min1' | cleanfunc == 'Min2'] <- "Minor"
cleanfunc[cleanfunc == 'Maj1' | cleanfunc == 'Maj2'] <- "Major"
cleanfunc[cleanfunc == 'Sev' | cleanfunc == 'Sal'] <- "Severe"
cleanfunc <- as.factor(cleanfunc)
```

```{r}
test$PoolQC <- cleanpool
test$Fence <- cleanfence
test$Functional <- cleanfunc
```


### Mileva: Heating, Electrical, FireplaceQu, HeatingQC, CentralAir
The processing for the Heating, Electrical, and FireplaceQu predictors is below. The HeatingQC and CentralAir predictors did not require any additional processing. 

```{r}
# Heating: Collapsed categores with low frequencies into "other"
heating <- as.factor(train_catPredictors$Heating)
heating <- fct_other(heating, keep=c("GasA", "GasW"))
train$Heating <- heating
```

```{r}
# Electrical: Collapsed similar categories together and handled missing values
electrical <- as.character(train_catPredictors$Electrical)

electrical <- fct_collapse(electrical, Fuse=c("FuseA", "FuseF", "FuseP"))
electrical <- fct_collapse(electrical, Other=c("Mix"))
electrical[is.na(electrical)] <- "Other"

train$Electrical <- electrical
```

```{r}
# Fireplace: Handled missing values
fireplace <- as.character(train_catPredictors$FireplaceQu)
fireplace[is.na(fireplace)] <- "none"
train$FireplaceQu <- as.factor(fireplace)
```

Need to do the same for test dataset:
```{r}
# Heating: Collapsed categores with low frequencies into "other"
heating <- as.factor(test_catPredictors$Heating)
heating <- fct_other(heating, keep=c("GasA", "GasW"))
test$Heating <- heating
```

```{r}
# Electrical: Collapsed similar categories together and handled missing values
electrical <- as.character(test_catPredictors$Electrical)

electrical <- fct_collapse(electrical, Fuse=c("FuseA", "FuseF", "FuseP"))
electrical <- fct_collapse(electrical, Other=c("Mix"))
electrical[is.na(electrical)] <- "Other"

test$Electrical <- electrical
```

```{r}
# Fireplace: Handled missing values
fireplace <- as.character(test_catPredictors$FireplaceQu)
fireplace[is.na(fireplace)] <- "none"
test$FireplaceQu <- as.factor(fireplace)
```


### Thomas: RoofMatl, Exterior1st/Exterior2nd, SaleType

# RoofMatl - Dropped

1434/1460 entries in the training set are CompShg.  
The off-materials aren't meaningfully different price-wise as an 'other' group.  Wood Shingles ('wdshngl') does contain 2 houses in the 99th percentile sale price, but with only 6 entries I don't think it's safe to include.  
I think we're better off dropping this one.
```{r}
train <- select(train, -c(RoofMatl))
test <- select(test, -c(RoofMatl))
```

### Exterior1st/2nd
Fixed the following label mis-matches between columns:Exterior1st - WdShing,CemntBd,BrkComm, Exterior2nd - Wd Shng,CmentBd,Brk Cmn

~90% of these two variables matched.
In the ~10% that didn't match, Exterior1st is generally a better predictor of sale price than Exterior2nd.
I converted Exterior2nd into a boolean, TRUE if Exterior1st!=Exterior2nd.

I combined the bottom half of Exterior1st's categories into an 'Other' category.
  (This leaves 7, but Brick Face/Cement Board seem to be decent categories for predicting sale price, so I didn't want to drop them.)

```{r}
train$Exterior2nd[train$Exterior2nd=='Wd Shng'] <- 'WdShing'
train$Exterior2nd[train$Exterior2nd=='CmentBd'] <- 'CemntBd'
train$Exterior2nd[train$Exterior2nd=='Brk Cmn'] <- 'BrkComm'
train$Exterior2nd <- train$Exterior1st!=train$Exterior2nd
train$Exterior1st <- fct_collapse(train$Exterior1st, Other = c("AsbShng","AsphShn","CBlock","ImStucc","BrkComm","Stone","Stucco","WdShing"))

test$Exterior2nd[test$Exterior2nd=='Wd Shng']<- 'WdShing'
test$Exterior2nd[test$Exterior2nd=='CmentBd']<- 'CemntBd'
test$Exterior2nd[test$Exterior2nd=='Brk Cmn']<- 'BrkComm'
test$Exterior2nd <- test$Exterior1st!=test$Exterior2nd
test$Exterior1st <- fct_collapse(test$Exterior1st, Other = c("AsbShng","AsphShn","CBlock","ImStucc","BrkComm","Stone","Stucco","WdShing"))
```
### SaleType
WD, New, and Court deed/estate were the three most common categories, and all 3 were significant when using SaleType as sole predictor.
Combined the other categories into 'Other'.
```{r}
train$SaleType <- fct_collapse(train$SaleType, Other = c("ConLD", "ConLw", "ConLI", "CWD", "Oth", "Con"))
test$SaleType <- fct_collapse(test$SaleType, Other = c("ConLD", "ConLw", "ConLI", "CWD", "Oth", "Con"))
```

### Marina: Neighborhood, GarageType, GarageFinish, GarageQual, GarageCond

```{r}
### Neighborhood ###
# Collapse categores with low frequencies into "other"

#Explore counts
train_catPredictors %>% count(Neighborhood, sort = TRUE)
```

```{r}
#Factorize
neighborhood <- as.factor(train_catPredictors$Neighborhood)

#Convert to "Other" any category that represents less than 2% of the data
neighborhood <- neighborhood %>% 
  fct_lump(prop=0.03, other_level='Other')

levels(neighborhood) #New levels of the factor
```


```{r}
#Update column with new values
train$Neighborhood <- neighborhood
```

Need to do the same on test data:
```{r}
#Factorize
neighborhood <- as.factor(test_catPredictors$Neighborhood)

#Convert to "Other" any category that represents less than 2% of the data
neighborhood <- neighborhood %>% 
  fct_lump(prop=0.03, other_level='Other')

levels(neighborhood) #New levels of the factor
```


```{r}
#Update column with new values
test$Neighborhood <- neighborhood
```

**Anyone sees the issue??**
```{r}
table(train$Neighborhood)
table(test$Neighborhood)
```

```{r}
### GarageType ###

#Explore counts
train_catPredictors %>% count(GarageType, sort = TRUE)
```

```{r}
#Handle NAs
#According to the data description, NA means no garage. 
#Change NA category to "none" to avoid issues.
garageType <- as.character(train_catPredictors$GarageType)
garageType[is.na(garageType)] <- "none"
garageType <- as.factor(garageType)
```

```{r}
#Collapse into "Other" categries that represent less than 5% of the data
garageType <- garageType %>% 
  fct_lump(prop=0.05, other_level='Other')

#levels(garageType) #New levels of the factor
```


```{r}
#Update column with new values
train$GarageType <- garageType
```

**Attention!! Need to do the same on the test data:** 
```{r}

```


```{r}
### GarageFinish ###

#Explore counts
train_catPredictors %>% count(GarageFinish, sort = TRUE)
```
```{r}
#Handle NAs
#According to the data description, NA means no garage. 
#Change NA category to "none" to avoid issues.
garageFinish <- as.character(train_catPredictors$GarageFinish)
garageFinish[is.na(garageFinish)] <- "none"
garageFinish <- as.factor(garageFinish)

#No need to collapse categories
```

```{r}
#Update column with new values
train$GarageFinish <- garageFinish
```

Need to do the same for the test data:
```{r}
#Handle NAs
#According to the data description, NA means no garage. 
#Change NA category to "none" to avoid issues.
garageFinish <- as.character(test_catPredictors$GarageFinish)
garageFinish[is.na(garageFinish)] <- "none"
garageFinish <- as.factor(garageFinish)
#No need to collapse categories
```

```{r}
#Update column with new values
test$GarageFinish <- garageFinish
```



```{r}
### GarageQual ###

#Explore counts
train_catPredictors %>% count(GarageQual, sort = TRUE)
```

```{r}
#Handle NAs
#According to the data description, NA means no garage. 
#Change NA category to "none" to avoid issues.
garageQual <- as.character(train_catPredictors$GarageQual)
garageQual[is.na(garageQual)] <- "none"
garageQual <- as.factor(garageQual)
```

```{r}
#Collapse categories: 
# - Let's collapse Ex	(Excellent) and Gd	(Good) into 1 category: Gd
# - Let's collapse Fa	(Fair) and Po	(Poor) into 1 category: Po
# - None and TA remains the same

garageQual <- fct_collapse(garageQual, Gd = c("Ex","Gd"))
garageQual <- fct_collapse(garageQual, Po = c("Fa","Po"))
```


```{r}
#Update column with new values
train$GarageQual <- garageQual
```

Need to do the same for test data:
```{r}
#Handle NAs
#According to the data description, NA means no garage. 
#Change NA category to "none" to avoid issues.
garageQual <- as.character(test_catPredictors$GarageQual)
garageQual[is.na(garageQual)] <- "none"
garageQual <- as.factor(garageQual)
```

```{r}
#Collapse categories: 
# - Let's collapse Ex	(Excellent) and Gd	(Good) into 1 category: Gd
# - Let's collapse Fa	(Fair) and Po	(Poor) into 1 category: Po
# - None and TA remains the same

garageQual <- fct_collapse(garageQual, Gd = c("Ex","Gd"))
garageQual <- fct_collapse(garageQual, Po = c("Fa","Po"))
```


```{r}
#Update column with new values
test$GarageQual <- garageQual
```


```{r}
### GarageCond ###

#Explore counts
train_catPredictors %>% count(GarageCond, sort = TRUE)
```

```{r}
#Handle NAs
#According to the data description, NA means no garage. 
#Change NA category to "none" to avoid issues.
garageCond <- as.character(train_catPredictors$GarageCond)
garageCond[is.na(garageCond)] <- "none"
garageCond <- as.factor(garageCond)
```

```{r}
#Collapse categories: 
# - Let's collapse Ex	(Excellent) and Gd	(Good) into 1 category: Gd
# - Let's collapse Fa	(Fair) and Po	(Poor) into 1 category: Po
# - None and TA remains the same

garageCond <- fct_collapse(garageCond, Gd = c("Ex","Gd"))
garageCond <- fct_collapse(garageCond, Po = c("Fa","Po"))

```

```{r}
#Update column with new values
train$GarageCond <- garageCond
```

Need to do the same with test data:
```{r}
#Handle NAs
#According to the data description, NA means no garage. 
#Change NA category to "none" to avoid issues.
garageCond <- as.character(test_catPredictors$GarageCond)
garageCond[is.na(garageCond)] <- "none"
garageCond <- as.factor(garageCond)
```

```{r}
#Collapse categories: 
# - Let's collapse Ex	(Excellent) and Gd	(Good) into 1 category: Gd
# - Let's collapse Fa	(Fair) and Po	(Poor) into 1 category: Po
# - None and TA remains the same

garageCond <- fct_collapse(garageCond, Gd = c("Ex","Gd"))
garageCond <- fct_collapse(garageCond, Po = c("Fa","Po"))

```

```{r}
#Update column with new values
test$GarageCond <- garageCond
```



### Paul: LotShape, LotConfig, LandContour

Fortunately there are no NA values in  either the test or train sets.
```{r}
sum(is.na(train$LotShape))
sum(is.na(test$LotShape))
sum(is.na(train$LotConfig))
sum(is.na(test$LotConfig))
sum(is.na(train$LandContour))
sum(is.na(test$LandContour))
```

```{r}
fct_count(train$LotShape)
fct_count(test$LotShape)
fct_count(train$LotConfig)
fct_count(test$LotConfig)
fct_count(train$LandContour)
fct_count(test$LandContour)
```

All of these variables are highly imbalanced. In each there is one category that represents a "regular" shape, configuration, or land contour, which amount for ~2/3 or more of the total instances. Thus, I collapsed all of the less represented "irregular" categories into one.

```{r}
train$LotShape <- fct_collapse(train$LotShape, Irregular = c("IR1", "IR2", "IR3"))
train$LotConfig <- fct_collapse(train$LotConfig, Other = c("Corner","CulDSac", "FR2", "FR3"))
train$LandContour <- fct_collapse(train$LandContour, NonLvl = c("Bnk", "HLS", "Low"))
```


```{r}
fct_count(train$LotShape)
fct_count(train$LotConfig)
fct_count(train$LandContour)
```

Need to do the same for the test data:
```{r}
test$LotShape <- fct_collapse(test$LotShape, Irregular = c("IR1", "IR2", "IR3"))
test$LotConfig <- fct_collapse(test$LotConfig, Other = c("Corner","CulDSac", "FR2", "FR3"))
test$LandContour <- fct_collapse(test$LandContour, NonLvl = c("Bnk", "HLS", "Low"))
```





